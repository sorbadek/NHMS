
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://guebnnhdjvdhjqescpeb.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd1ZWJubmhkanZkaGpxZXNjcGViIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI1NDgxNTYsImV4cCI6MjA1ODEyNDE1Nn0.ddem8_jTEW7EAfDxcwmqbZ8TgvQpGbtjJwmlDtW2_YU";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create a custom type that extends the Database type to include the appointments table
// until the generated types are updated
export type AppointmentRow = {
  id: string;
  patient_id?: string | null;
  hospital_id?: string | null;
  doctor_id?: string | null;
  department?: string | null;
  appointment_date: string;
  reason?: string | null;
  status?: string | null;
  notes?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type PatientRow = {
  id: string;
  user_id?: string | null;
  full_name?: string;
  date_of_birth?: string | null;
  gender?: string | null;
  blood_type?: string | null;
  allergies?: string | null;
  emergency_contact_name?: string | null;
  emergency_contact_phone?: string | null;
  national_id?: string | null;
  status?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type UserRow = {
  id: string;
  full_name?: string | null;
  email?: string | null;
  phone?: string | null;
  user_type?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type HospitalRow = {
  id: string;
  name: string;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  phone?: string | null;
  email?: string | null;
  license_number?: string | null;
  status?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type HospitalStaffRow = {
  id: string;
  user_id?: string | null;
  hospital_id?: string | null;
  role: string;
  role_specific?: string | null;
  department?: string | null;
  status?: string | null;
  specialization?: string | null;
  license_number?: string | null;
  education?: string | null;
  years_of_experience?: number | null;
  shift_preference?: string | null;
  registration_date?: string | null;
  certification?: string[] | null;
  created_at?: string | null;
  updated_at?: string | null;
};

// User roles - expanded to include all role types
export enum UserRole {
  SUPER_ADMIN = 'super_admin',
  HOSPITAL_ADMIN = 'hospital_admin',
  DOCTOR = 'doctor',
  NURSE = 'nurse',
  LAB_TECHNICIAN = 'lab_technician',
  PHARMACIST = 'pharmacist',
  RECEPTIONIST = 'receptionist',
  POLICE_ADMIN = 'police_admin',
  POLICE_OFFICER = 'police_officer',
  PATIENT = 'patient'
}

// Staff specific roles from the enum
export enum StaffRole {
  DOCTOR = 'doctor',
  NURSE = 'nurse',
  RECEPTIONIST = 'receptionist',
  LAB_TECHNICIAN = 'lab_technician',
  PHARMACIST = 'pharmacist',
  ADMINISTRATOR = 'administrator',
  RADIOLOGIST = 'radiologist',
  PHYSIOTHERAPIST = 'physiotherapist',
  NUTRITIONIST = 'nutritionist',
  SECURITY = 'security',
  MAINTENANCE = 'maintenance',
  IT_SUPPORT = 'it_support',
  HOSPITAL_ADMIN = 'hospital_admin'
}

// Extend Database type to include the appointments table
export type ExtendedDatabase = Database & {
  public: {
    Tables: Database['public']['Tables'] & {
      appointments: {
        Row: AppointmentRow;
        Insert: Omit<AppointmentRow, 'id' | 'created_at' | 'updated_at'> & { id?: string };
        Update: Partial<Omit<AppointmentRow, 'id'>>;
        Relationships: [
          {
            foreignKeyName: 'appointments_patient_id_fkey';
            columns: ['patient_id'];
            referencedRelation: 'patients';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'appointments_hospital_id_fkey';
            columns: ['hospital_id'];
            referencedRelation: 'hospitals';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'appointments_doctor_id_fkey';
            columns: ['doctor_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          }
        ];
      };
      hospital_staff: {
        Row: HospitalStaffRow;
        Insert: Omit<HospitalStaffRow, 'id' | 'created_at' | 'updated_at'> & { id?: string };
        Update: Partial<Omit<HospitalStaffRow, 'id'>>;
        Relationships: [
          {
            foreignKeyName: 'hospital_staff_hospital_id_fkey';
            columns: ['hospital_id'];
            referencedRelation: 'hospitals';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'hospital_staff_user_id_fkey';
            columns: ['user_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          }
        ];
      };
    };
  };
};

export const supabase = createClient<ExtendedDatabase>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper for typecasting tables
export type Tables = ExtendedDatabase['public']['Tables'];

// Helper for working with nested joins in queries
export type WithJoins<T> = T & Record<string, any>;

// Type helper for appointments with joins
export type AppointmentWithJoins = AppointmentRow & {
  patients?: PatientRow | UserRow | Record<string, any> | null;
  doctors?: UserRow | Record<string, any> | null;
  hospitals?: HospitalRow | Record<string, any> | null;
};

// Type helper for staff with joins
export type StaffWithJoins = HospitalStaffRow & {
  users?: UserRow | null;
  hospitals?: HospitalRow | null;
};

// Helper function to safely extract nested data
export const extractNestedData = <T extends Record<string, any> | null | undefined, K extends string>(
  obj: T,
  key: K
): any => {
  if (!obj) return undefined;
  return obj[key];
};

// Helper function to get a property from a nested object with type safety
export const getNestedProperty = (obj: any, prop: string, fallback: any = null): any => {
  if (!obj || typeof obj !== 'object') return fallback;
  return obj[prop] !== undefined ? obj[prop] : fallback;
};

// Email notification utility
export const sendEmailNotification = async (
  to: string,
  subject: string,
  content: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    const { data, error } = await supabase.functions.invoke('send-email', {
      body: { to, subject, content }
    });
    
    if (error) throw error;
    
    return { success: true };
  } catch (error: any) {
    console.error("Failed to send email notification:", error);
    return { 
      success: false, 
      error: error.message || "Failed to send email notification" 
    };
  }
};

// Authentication helper function with role verification
export const getUserWithRole = async (): Promise<{
  user: UserRow | null;
  role: string | null;
  organization_id: string | null;
}> => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return { user: null, role: null, organization_id: null };
    }
    
    // Get user data
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('*')
      .eq('id', session.user.id)
      .single();
    
    if (userError) {
      console.error("Error fetching user data:", userError);
      return { user: null, role: null, organization_id: null };
    }
    
    let role = null;
    let organization_id = null;
    
    // Determine role and organization based on user type
    if (userData.user_type === 'hospital_staff') {
      const { data: staffData } = await supabase
        .from('hospital_staff')
        .select('*')
        .eq('user_id', session.user.id)
        .single();
      
      if (staffData) {
        role = staffData.role;
        organization_id = staffData.hospital_id;
      }
    } else if (userData.user_type === 'police') {
      const { data: officerData } = await supabase
        .from('police_officers')
        .select('*')
        .eq('user_id', session.user.id)
        .single();
      
      if (officerData) {
        role = officerData.rank;
        organization_id = officerData.department_id;
      }
    } else {
      // For patient or admin
      role = userData.user_type;
    }
    
    return { user: userData, role, organization_id };
  } catch (error) {
    console.error("Error in getUserWithRole:", error);
    return { user: null, role: null, organization_id: null };
  }
};

// Format date helper
export const formatDate = (dateString: string | null | undefined): string => {
  if (!dateString) return '';
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-NG', {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    });
  } catch (error) {
    console.error("Error formatting date:", error);
    return '';
  }
};

// Format time helper
export const formatTime = (dateString: string | null | undefined): string => {
  if (!dateString) return '';
  try {
    const date = new Date(dateString);
    return date.toLocaleTimeString('en-NG', {
      hour: '2-digit',
      minute: '2-digit'
    });
  } catch (error) {
    console.error("Error formatting time:", error);
    return '';
  }
};
